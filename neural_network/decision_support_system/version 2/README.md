Добро пожаловать в репозиторий СППР, реализующей логику и принятие решений. СППР является связующим звеном между беспилотниками, операторами и службами быстрого реагирования. На данный момент поддерживаются два сценария взаимодействия: 
- удалённое управление беспилотником;
- распознавание черезвычайных ситуаций. 

# Как управлять?
Удалённое управление беспилотником осуществляется посредством телеграмм-бота. Для каждого беспилотника существует свой бот.

|Название|Имя в телеграмме|Описание|
|:------:|:--------------:|:-------|
|Альфа|[@copteroperatorbot]( https://t.me/copteroperatorbot)|Первый беспилотник в системе мониторинга. В настоящий момент используется для тестов.|

Для управления беспилотником следуйте следующей инструкции:
1. В телеграмме начните чат с нужным беспилотником, например [Альфа]( https://t.me/copteroperatorbot);
2. Введите пароль от беспилотника;
2. Отправляйте команды и получайте рассылку с распознанными черезвычайными ситуациями. 
 
Список доступных команд можно посмотреть прямо в чате телеграмма или ниже:
- /start - подключается к беспилотнику;
- /stop - отключается от беспилотника.

*Бот обрабатывает все, но отвечает лишь на последнюю команду.*

# Класс Operator.py
## Интерфейс
Функционал СППР описывает интерфейс [IOperator](IOperator.py). Вы можете использовать данный интерфейс для быстрого прототипирования работы с СППР. Данный класс не выполняет никаких действий, а лишь предоставляет функции для своей интеграции в код программы.

Создайте экземпляр интерфейса, после чего вы сможете испольовать следующие методы:

- `send(photo: bytes, score: float) -> None` - Отправить фотографию (кадр) в СППР, где photo - байтовое представление фотографии (формат задаётся телеграммом), score - вероятность распознания на фотографии черезвычайного события.
- `subscribe(event: int, callback: Callable[[], None], unique: bool = False) -> None` - Подписаться на событие,где event - номер события, callback - функция, которая будет вызвана при наступлении события; unique - запретить подписываться одной функции несколько раз?
- `unsubscribe(event: int, callback: Callable[[], None]) -> None` - Отписаться от события. Выбрасывает исключение, если функция не была подписана на указанное событие, event - номер события, callback - функция, которая подписана на событие.
- `wait(loop=True) -> None` - Заблокировать поток и ожидать подключения оператора; loop - ожидать следующего оператора после отключения последнего?

Список событий представлен ниже:

|Номер|Описание|
|:---:|--------|
|0|Подключение оператора|
|1|Отключение оператора|

## Как использовать?
СППР и взаимодействие с оператором реализует класс [Operator](Operator.py). Если вы использовали интерфейс, то замените IOperator на Operator. 

После создания экземпляра класса вызывайте метод `send` для каждого кадра видеопотока.
```python
from Operator import Operator

operator = Operator()
while True:  # Main loop
    # Do stuff.
    frame, confidence = ... # Capture frame and detect danger.
    operator.send(frame,confidence) # Send detection.
    # Some other stuff.
```

СППР автоматически синхронизируется с FPS видеопотока.

# Класс ROSHelper.py
Данный класс помогает отправлять сообщения в ROS. Он рассчитан на 100 сообщей за итерацию (кадр).
1. Создайте новый экзмепляр.
2. Вызовите функцию `SendMessage(text: std_msgs.msgString) -> None`, передав текст сообщения. 
3. Сообщение *text* будет передано в ROS.

Если ROS недоступен, сообщение игнорируется.

Пример отправки сообщения 'stop'.
```python
from ROSHelper import ROSHelper

helper = ROSHelper
helper.SendMessage('stop')
```
